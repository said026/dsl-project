/*
 * generated by Xtext 2.12.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.fM.Constraints;
import org.xtext.fM.FMPackage;
import org.xtext.fM.FeatureDiagram;
import org.xtext.fM.FeatureModel;
import org.xtext.fM.Leaf;
import org.xtext.fM.Node;
import org.xtext.fM.Rule;
import org.xtext.fM.RuleElement;
import org.xtext.fM.Var;
import org.xtext.services.FMGrammarAccess;

@SuppressWarnings("all")
public class FMSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FMGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FMPackage.CONSTRAINTS:
				sequence_Constraints(context, (Constraints) semanticObject); 
				return; 
			case FMPackage.FEATURE_DIAGRAM:
				sequence_FeatureDiagram(context, (FeatureDiagram) semanticObject); 
				return; 
			case FMPackage.FEATURE_MODEL:
				sequence_FeatureModel(context, (FeatureModel) semanticObject); 
				return; 
			case FMPackage.LEAF:
				sequence_Leaf(context, (Leaf) semanticObject); 
				return; 
			case FMPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case FMPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case FMPackage.RULE_ELEMENT:
				sequence_RuleElement(context, (RuleElement) semanticObject); 
				return; 
			case FMPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Constraints returns Constraints
	 *
	 * Constraint:
	 *     rules+=Rule+
	 */
	protected void sequence_Constraints(ISerializationContext context, Constraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureDiagram returns FeatureDiagram
	 *
	 * Constraint:
	 *     root=Child
	 */
	protected void sequence_FeatureDiagram(ISerializationContext context, FeatureDiagram semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.FEATURE_DIAGRAM__ROOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.FEATURE_DIAGRAM__ROOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureDiagramAccess().getRootChildParserRuleCall_1_0(), semanticObject.getRoot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureModel returns FeatureModel
	 *
	 * Constraint:
	 *     (diagram=FeatureDiagram constraints=Constraints)
	 */
	protected void sequence_FeatureModel(ISerializationContext context, FeatureModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.FEATURE_MODEL__DIAGRAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.FEATURE_MODEL__DIAGRAM));
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.FEATURE_MODEL__CONSTRAINTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.FEATURE_MODEL__CONSTRAINTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureModelAccess().getDiagramFeatureDiagramParserRuleCall_1_0(), semanticObject.getDiagram());
		feeder.accept(grammarAccess.getFeatureModelAccess().getConstraintsConstraintsParserRuleCall_2_0(), semanticObject.getConstraints());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Leaf
	 *     Leaf returns Leaf
	 *
	 * Constraint:
	 *     (mandatory?='mandatory'? name=ID)
	 */
	protected void sequence_Leaf(ISerializationContext context, Leaf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Child returns Node
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (open_relation=RELATION mandatory?='mandatory'? name=ID children+=Child+ close_relation=RELATION)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns RuleElement
	 *     Formula returns RuleElement
	 *
	 * Constraint:
	 *     (open_operator=OPERATOR left_side=Var right_side=Var close_operator=OPERATOR)
	 */
	protected void sequence_RuleElement(ISerializationContext context, RuleElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.RULE_ELEMENT__OPEN_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.RULE_ELEMENT__OPEN_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.RULE_ELEMENT__LEFT_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.RULE_ELEMENT__LEFT_SIDE));
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.RULE_ELEMENT__RIGHT_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.RULE_ELEMENT__RIGHT_SIDE));
			if (transientValues.isValueTransient(semanticObject, FMPackage.Literals.RULE_ELEMENT__CLOSE_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FMPackage.Literals.RULE_ELEMENT__CLOSE_OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleElementAccess().getOpen_operatorOPERATORTerminalRuleCall_1_0(), semanticObject.getOpen_operator());
		feeder.accept(grammarAccess.getRuleElementAccess().getLeft_sideVarParserRuleCall_3_0(), semanticObject.getLeft_side());
		feeder.accept(grammarAccess.getRuleElementAccess().getRight_sideVarParserRuleCall_4_0(), semanticObject.getRight_side());
		feeder.accept(grammarAccess.getRuleElementAccess().getClose_operatorOPERATORTerminalRuleCall_6_0(), semanticObject.getClose_operator());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     elements+=Formula+
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (not?='not'? name=ID)
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
